//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension DevOpsGuru {
    // MARK: Enums

    public enum AnomalySeverity: String, CustomStringConvertible, Codable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum AnomalyStatus: String, CustomStringConvertible, Codable {
        case closed = "CLOSED"
        case ongoing = "ONGOING"
        public var description: String { return self.rawValue }
    }

    public enum CloudWatchMetricsStat: String, CustomStringConvertible, Codable {
        case average = "Average"
        case maximum = "Maximum"
        case minimum = "Minimum"
        case p50
        case p90
        case p99
        case samplecount = "SampleCount"
        case sum = "Sum"
        public var description: String { return self.rawValue }
    }

    public enum EventClass: String, CustomStringConvertible, Codable {
        case configChange = "CONFIG_CHANGE"
        case deployment = "DEPLOYMENT"
        case infrastructure = "INFRASTRUCTURE"
        case schemaChange = "SCHEMA_CHANGE"
        case securityChange = "SECURITY_CHANGE"
        public var description: String { return self.rawValue }
    }

    public enum EventDataSource: String, CustomStringConvertible, Codable {
        case awsCloudTrail = "AWS_CLOUD_TRAIL"
        case awsCodeDeploy = "AWS_CODE_DEPLOY"
        public var description: String { return self.rawValue }
    }

    public enum InsightFeedbackOption: String, CustomStringConvertible, Codable {
        case alertTooSensitive = "ALERT_TOO_SENSITIVE"
        case dataIncorrect = "DATA_INCORRECT"
        case dataNoisyAnomaly = "DATA_NOISY_ANOMALY"
        case recommendationUseful = "RECOMMENDATION_USEFUL"
        case validCollection = "VALID_COLLECTION"
        public var description: String { return self.rawValue }
    }

    public enum InsightSeverity: String, CustomStringConvertible, Codable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum InsightStatus: String, CustomStringConvertible, Codable {
        case closed = "CLOSED"
        case ongoing = "ONGOING"
        public var description: String { return self.rawValue }
    }

    public enum InsightType: String, CustomStringConvertible, Codable {
        case proactive = "PROACTIVE"
        case reactive = "REACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum OptInStatus: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ResourceCollectionType: String, CustomStringConvertible, Codable {
        case awsCloudFormation = "AWS_CLOUD_FORMATION"
        public var description: String { return self.rawValue }
    }

    public enum UpdateResourceCollectionAction: String, CustomStringConvertible, Codable {
        case add = "ADD"
        case remove = "REMOVE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddNotificationChannelRequest: AWSEncodableShape {
        ///  A NotificationChannelConfig object that specifies what type of notification channel to add. The one supported notification channel is Amazon Simple Notification Service (Amazon SNS).
        public let config: NotificationChannelConfig

        public init(config: NotificationChannelConfig) {
            self.config = config
        }

        public func validate(name: String) throws {
            try self.config.validate(name: "\(name).config")
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
        }
    }

    public struct AddNotificationChannelResponse: AWSDecodableShape {
        ///  The ID of the added notification channel.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct AnomalySourceDetails: AWSDecodableShape {
        ///  An array of CloudWatchMetricsDetail object that contains information about the analyzed metrics that displayed anomalous behavior.
        public let cloudWatchMetrics: [CloudWatchMetricsDetail]?

        public init(cloudWatchMetrics: [CloudWatchMetricsDetail]? = nil) {
            self.cloudWatchMetrics = cloudWatchMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchMetrics = "CloudWatchMetrics"
        }
    }

    public struct AnomalyTimeRange: AWSDecodableShape {
        ///  The time when the anomalous behavior ended.
        public let endTime: Date?
        ///  The time when the anomalous behavior started.
        public let startTime: Date

        public init(endTime: Date? = nil, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct CloudFormationCollection: AWSEncodableShape & AWSDecodableShape {
        ///  An array of CloudFormation stack names.
        public let stackNames: [String]?

        public init(stackNames: [String]? = nil) {
            self.stackNames = stackNames
        }

        public func validate(name: String) throws {
            try self.stackNames?.forEach {
                try validate($0, name: "stackNames[]", parent: name, max: 128)
                try validate($0, name: "stackNames[]", parent: name, min: 1)
                try validate($0, name: "stackNames[]", parent: name, pattern: "^[a-zA-Z*]+[a-zA-Z0-9-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case stackNames = "StackNames"
        }
    }

    public struct CloudFormationCollectionFilter: AWSDecodableShape {
        ///  An array of CloudFormation stack names.
        public let stackNames: [String]?

        public init(stackNames: [String]? = nil) {
            self.stackNames = stackNames
        }

        private enum CodingKeys: String, CodingKey {
            case stackNames = "StackNames"
        }
    }

    public struct CloudFormationHealth: AWSDecodableShape {
        ///  Information about the health of the AWS resources in your account that are specified by an AWS CloudFormation stack, including the number of open proactive, open reactive insights, and the Mean Time to Recover (MTTR) of closed insights.
        public let insight: InsightHealth?
        ///  The name of the CloudFormation stack.
        public let stackName: String?

        public init(insight: InsightHealth? = nil, stackName: String? = nil) {
            self.insight = insight
            self.stackName = stackName
        }

        private enum CodingKeys: String, CodingKey {
            case insight = "Insight"
            case stackName = "StackName"
        }
    }

    public struct CloudWatchMetricsDetail: AWSDecodableShape {
        ///  An array of CloudWatch dimensions associated with
        public let dimensions: [CloudWatchMetricsDimension]?
        ///  The name of the CloudWatch metric.
        public let metricName: String?
        ///  The namespace of the CloudWatch metric. A namespace is a container for CloudWatch metrics.
        public let namespace: String?
        ///  The length of time associated with the CloudWatch metric in number of seconds.
        public let period: Int?
        ///  The type of statistic associated with the CloudWatch metric. For more information, see Statistics in the Amazon CloudWatch User Guide.
        public let stat: CloudWatchMetricsStat?
        ///  The unit of measure used for the CloudWatch metric. For example, Bytes, Seconds, Count, and Percent.
        public let unit: String?

        public init(dimensions: [CloudWatchMetricsDimension]? = nil, metricName: String? = nil, namespace: String? = nil, period: Int? = nil, stat: CloudWatchMetricsStat? = nil, unit: String? = nil) {
            self.dimensions = dimensions
            self.metricName = metricName
            self.namespace = namespace
            self.period = period
            self.stat = stat
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case metricName = "MetricName"
            case namespace = "Namespace"
            case period = "Period"
            case stat = "Stat"
            case unit = "Unit"
        }
    }

    public struct CloudWatchMetricsDimension: AWSDecodableShape {
        ///  The name of the CloudWatch dimension.
        public let name: String?
        ///  The value of the CloudWatch dimension.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct DescribeAccountHealthRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeAccountHealthResponse: AWSDecodableShape {
        ///  An integer that specifies the number of metrics that have been analyzed in your AWS account.
        public let metricsAnalyzed: Int
        ///  An integer that specifies the number of open proactive insights in your AWS account.
        public let openProactiveInsights: Int
        ///  An integer that specifies the number of open reactive insights in your AWS account.
        public let openReactiveInsights: Int
        /// The number of Amazon DevOps Guru resource analysis hours billed to the current AWS account in the last hour.
        public let resourceHours: Int64

        public init(metricsAnalyzed: Int, openProactiveInsights: Int, openReactiveInsights: Int, resourceHours: Int64) {
            self.metricsAnalyzed = metricsAnalyzed
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
            self.resourceHours = resourceHours
        }

        private enum CodingKeys: String, CodingKey {
            case metricsAnalyzed = "MetricsAnalyzed"
            case openProactiveInsights = "OpenProactiveInsights"
            case openReactiveInsights = "OpenReactiveInsights"
            case resourceHours = "ResourceHours"
        }
    }

    public struct DescribeAccountOverviewRequest: AWSEncodableShape {
        ///  The start of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred after this day.
        public let fromTime: Date
        ///  The end of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred before this day. If this is not specified, then the current day is used.
        public let toTime: Date?

        public init(fromTime: Date, toTime: Date? = nil) {
            self.fromTime = fromTime
            self.toTime = toTime
        }

        private enum CodingKeys: String, CodingKey {
            case fromTime = "FromTime"
            case toTime = "ToTime"
        }
    }

    public struct DescribeAccountOverviewResponse: AWSDecodableShape {
        ///  The Mean Time to Recover (MTTR) for all closed insights that were created during the time range passed in.
        public let meanTimeToRecoverInMilliseconds: Int64
        ///  An integer that specifies the number of open proactive insights in your AWS account that were created during the time range passed in.
        public let proactiveInsights: Int
        ///  An integer that specifies the number of open reactive insights in your AWS account that were created during the time range passed in.
        public let reactiveInsights: Int

        public init(meanTimeToRecoverInMilliseconds: Int64, proactiveInsights: Int, reactiveInsights: Int) {
            self.meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds
            self.proactiveInsights = proactiveInsights
            self.reactiveInsights = reactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case meanTimeToRecoverInMilliseconds = "MeanTimeToRecoverInMilliseconds"
            case proactiveInsights = "ProactiveInsights"
            case reactiveInsights = "ReactiveInsights"
        }
    }

    public struct DescribeAnomalyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id"))
        ]

        ///  The ID of the anomaly.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\w-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAnomalyResponse: AWSDecodableShape {
        ///  An ReactiveAnomaly object that represents the requested anomaly.
        public let proactiveAnomaly: ProactiveAnomaly?
        ///  An ProactiveAnomaly object that represents the requested anomaly.
        public let reactiveAnomaly: ReactiveAnomaly?

        public init(proactiveAnomaly: ProactiveAnomaly? = nil, reactiveAnomaly: ReactiveAnomaly? = nil) {
            self.proactiveAnomaly = proactiveAnomaly
            self.reactiveAnomaly = reactiveAnomaly
        }

        private enum CodingKeys: String, CodingKey {
            case proactiveAnomaly = "ProactiveAnomaly"
            case reactiveAnomaly = "ReactiveAnomaly"
        }
    }

    public struct DescribeFeedbackRequest: AWSEncodableShape {
        ///  The ID of the insight for which the feedback was provided.
        public let insightId: String?

        public init(insightId: String? = nil) {
            self.insightId = insightId
        }

        public func validate(name: String) throws {
            try self.validate(self.insightId, name: "insightId", parent: name, max: 100)
            try self.validate(self.insightId, name: "insightId", parent: name, min: 1)
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "^[\\w-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case insightId = "InsightId"
        }
    }

    public struct DescribeFeedbackResponse: AWSDecodableShape {
        public let insightFeedback: InsightFeedback?

        public init(insightFeedback: InsightFeedback? = nil) {
            self.insightFeedback = insightFeedback
        }

        private enum CodingKeys: String, CodingKey {
            case insightFeedback = "InsightFeedback"
        }
    }

    public struct DescribeInsightRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id"))
        ]

        ///  The ID of the insight.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\w-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeInsightResponse: AWSDecodableShape {
        ///  An ProactiveInsight object that represents the requested insight.
        public let proactiveInsight: ProactiveInsight?
        ///  An ReactiveInsight object that represents the requested insight.
        public let reactiveInsight: ReactiveInsight?

        public init(proactiveInsight: ProactiveInsight? = nil, reactiveInsight: ReactiveInsight? = nil) {
            self.proactiveInsight = proactiveInsight
            self.reactiveInsight = reactiveInsight
        }

        private enum CodingKeys: String, CodingKey {
            case proactiveInsight = "ProactiveInsight"
            case reactiveInsight = "ReactiveInsight"
        }
    }

    public struct DescribeResourceCollectionHealthRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken")),
            AWSMemberEncoding(label: "resourceCollectionType", location: .uri(locationName: "ResourceCollectionType"))
        ]

        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        ///  An AWS resource collection type. This type specifies how analyzed AWS resources are defined. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze only the AWS resources that are defined in the stacks.
        public let resourceCollectionType: ResourceCollectionType

        public init(nextToken: String? = nil, resourceCollectionType: ResourceCollectionType) {
            self.nextToken = nextToken
            self.resourceCollectionType = resourceCollectionType
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeResourceCollectionHealthResponse: AWSDecodableShape {
        ///  The returned CloudFormationHealthOverview object that contains an InsightHealthOverview object with the requested system health information.
        public let cloudFormation: [CloudFormationHealth]
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        public init(cloudFormation: [CloudFormationHealth], nextToken: String? = nil) {
            self.cloudFormation = cloudFormation
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "CloudFormation"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeServiceIntegrationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeServiceIntegrationResponse: AWSDecodableShape {
        public let serviceIntegration: ServiceIntegrationConfig?

        public init(serviceIntegration: ServiceIntegrationConfig? = nil) {
            self.serviceIntegration = serviceIntegration
        }

        private enum CodingKeys: String, CodingKey {
            case serviceIntegration = "ServiceIntegration"
        }
    }

    public struct EndTimeRange: AWSEncodableShape {
        ///  The earliest end time in the time range.
        public let fromTime: Date?
        ///  The latest end time in the time range.
        public let toTime: Date?

        public init(fromTime: Date? = nil, toTime: Date? = nil) {
            self.fromTime = fromTime
            self.toTime = toTime
        }

        private enum CodingKeys: String, CodingKey {
            case fromTime = "FromTime"
            case toTime = "ToTime"
        }
    }

    public struct Event: AWSDecodableShape {
        ///  The source, AWS_CLOUD_TRAIL or AWS_CODE_DEPLOY, where DevOps Guru analysis found the event.
        public let dataSource: EventDataSource?
        ///  The class of the event. The class specifies what the event is related to, such as an infrastructure change, a deployment, or a schema change.
        public let eventClass: EventClass?
        ///  The AWS source that emitted the event.
        public let eventSource: String?
        ///  The ID of the event.
        public let id: String?
        ///  The name of the event.
        public let name: String?
        public let resourceCollection: ResourceCollection?
        ///  An EventResource object that contains information about the resource that emitted the event.
        public let resources: [EventResource]?
        ///  A Timestamp that specifies the time the event occurred.
        public let time: Date?

        public init(dataSource: EventDataSource? = nil, eventClass: EventClass? = nil, eventSource: String? = nil, id: String? = nil, name: String? = nil, resourceCollection: ResourceCollection? = nil, resources: [EventResource]? = nil, time: Date? = nil) {
            self.dataSource = dataSource
            self.eventClass = eventClass
            self.eventSource = eventSource
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.resources = resources
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case eventClass = "EventClass"
            case eventSource = "EventSource"
            case id = "Id"
            case name = "Name"
            case resourceCollection = "ResourceCollection"
            case resources = "Resources"
            case time = "Time"
        }
    }

    public struct EventResource: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the resource that emitted an event.
        public let arn: String?
        ///  The name of the resource that emitted an event.
        public let name: String?
        ///  The type of resource that emitted an event.
        public let type: String?

        public init(arn: String? = nil, name: String? = nil, type: String? = nil) {
            self.arn = arn
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct EventTimeRange: AWSEncodableShape {
        ///  The time when the event started.
        public let fromTime: Date
        ///  The time when the event ended.
        public let toTime: Date

        public init(fromTime: Date, toTime: Date) {
            self.fromTime = fromTime
            self.toTime = toTime
        }

        private enum CodingKeys: String, CodingKey {
            case fromTime = "FromTime"
            case toTime = "ToTime"
        }
    }

    public struct GetResourceCollectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken")),
            AWSMemberEncoding(label: "resourceCollectionType", location: .uri(locationName: "ResourceCollectionType"))
        ]

        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        ///  The type of AWS resource collections to return. The one valid value is CLOUD_FORMATION for AWS CloudFormation stacks.
        public let resourceCollectionType: ResourceCollectionType

        public init(nextToken: String? = nil, resourceCollectionType: ResourceCollectionType) {
            self.nextToken = nextToken
            self.resourceCollectionType = resourceCollectionType
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourceCollectionResponse: AWSDecodableShape {
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        ///  The requested list of AWS resource collections. The one type of AWS resource collection supported is AWS CloudFormation stacks. DevOps Guru can be configured to analyze only the AWS resources that are defined in the stacks.
        public let resourceCollection: ResourceCollectionFilter?

        public init(nextToken: String? = nil, resourceCollection: ResourceCollectionFilter? = nil) {
            self.nextToken = nextToken
            self.resourceCollection = resourceCollection
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourceCollection = "ResourceCollection"
        }
    }

    public struct InsightFeedback: AWSEncodableShape & AWSDecodableShape {
        ///  The feedback provided by the customer.
        public let feedback: InsightFeedbackOption?
        ///  The insight feedback ID.
        public let id: String?

        public init(feedback: InsightFeedbackOption? = nil, id: String? = nil) {
            self.feedback = feedback
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\w-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case feedback = "Feedback"
            case id = "Id"
        }
    }

    public struct InsightHealth: AWSDecodableShape {
        ///  The Meant Time to Recover (MTTR) for the insight.
        public let meanTimeToRecoverInMilliseconds: Int64?
        ///  The number of open proactive insights.
        public let openProactiveInsights: Int?
        ///  The number of open reactive insights.
        public let openReactiveInsights: Int?

        public init(meanTimeToRecoverInMilliseconds: Int64? = nil, openProactiveInsights: Int? = nil, openReactiveInsights: Int? = nil) {
            self.meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case meanTimeToRecoverInMilliseconds = "MeanTimeToRecoverInMilliseconds"
            case openProactiveInsights = "OpenProactiveInsights"
            case openReactiveInsights = "OpenReactiveInsights"
        }
    }

    public struct InsightTimeRange: AWSDecodableShape {
        ///  The time when the behavior described in an insight ended.
        public let endTime: Date?
        ///  The time when the behavior described in an insight started.
        public let startTime: Date

        public init(endTime: Date? = nil, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct ListAnomaliesForInsightRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "insightId", location: .uri(locationName: "InsightId"))
        ]

        ///  The ID of the insight. The returned anomalies belong to this insight.
        public let insightId: String
        /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        ///  A time range used to specify when the requested anomalies started. All returned anomalies started during this time range.
        public let startTimeRange: StartTimeRange?

        public init(insightId: String, maxResults: Int? = nil, nextToken: String? = nil, startTimeRange: StartTimeRange? = nil) {
            self.insightId = insightId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTimeRange = startTimeRange
        }

        public func validate(name: String) throws {
            try self.validate(self.insightId, name: "insightId", parent: name, max: 100)
            try self.validate(self.insightId, name: "insightId", parent: name, min: 1)
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "^[\\w-]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTimeRange = "StartTimeRange"
        }
    }

    public struct ListAnomaliesForInsightResponse: AWSDecodableShape {
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        ///  An array of ProactiveAnomalySummary objects that represent the requested anomalies
        public let proactiveAnomalies: [ProactiveAnomalySummary]?
        ///  An array of ReactiveAnomalySummary objects that represent the requested anomalies
        public let reactiveAnomalies: [ReactiveAnomalySummary]?

        public init(nextToken: String? = nil, proactiveAnomalies: [ProactiveAnomalySummary]? = nil, reactiveAnomalies: [ReactiveAnomalySummary]? = nil) {
            self.nextToken = nextToken
            self.proactiveAnomalies = proactiveAnomalies
            self.reactiveAnomalies = reactiveAnomalies
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proactiveAnomalies = "ProactiveAnomalies"
            case reactiveAnomalies = "ReactiveAnomalies"
        }
    }

    public struct ListEventsFilters: AWSEncodableShape {
        ///  The source, AWS_CLOUD_TRAIL or AWS_CODE_DEPLOY, of the events you want returned.
        public let dataSource: EventDataSource?
        ///  The class of the events you want to filter for, such as an infrastructure change, a deployment, or a schema change.
        public let eventClass: EventClass?
        ///  The AWS source that emitted the events you want to filter for.
        public let eventSource: String?
        ///  A time range during which you want the filtered events to have occurred.
        public let eventTimeRange: EventTimeRange?
        ///  An ID of an insight that is related to the events you want to filter for.
        public let insightId: String?
        public let resourceCollection: ResourceCollection?

        public init(dataSource: EventDataSource? = nil, eventClass: EventClass? = nil, eventSource: String? = nil, eventTimeRange: EventTimeRange? = nil, insightId: String? = nil, resourceCollection: ResourceCollection? = nil) {
            self.dataSource = dataSource
            self.eventClass = eventClass
            self.eventSource = eventSource
            self.eventTimeRange = eventTimeRange
            self.insightId = insightId
            self.resourceCollection = resourceCollection
        }

        public func validate(name: String) throws {
            try self.validate(self.eventSource, name: "eventSource", parent: name, max: 50)
            try self.validate(self.eventSource, name: "eventSource", parent: name, min: 10)
            try self.validate(self.eventSource, name: "eventSource", parent: name, pattern: "^[a-z]+[a-z0-9]*\\.amazonaws\\.com|aws\\.events$")
            try self.validate(self.insightId, name: "insightId", parent: name, max: 100)
            try self.validate(self.insightId, name: "insightId", parent: name, min: 1)
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "^[\\w-]*$")
            try self.resourceCollection?.validate(name: "\(name).resourceCollection")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case eventClass = "EventClass"
            case eventSource = "EventSource"
            case eventTimeRange = "EventTimeRange"
            case insightId = "InsightId"
            case resourceCollection = "ResourceCollection"
        }
    }

    public struct ListEventsRequest: AWSEncodableShape {
        ///  A ListEventsFilters object used to specify which events to return.
        public let filters: ListEventsFilters
        /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        public init(filters: ListEventsFilters, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventsResponse: AWSDecodableShape {
        ///  A list of the requested events.
        public let events: [Event]
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        public init(events: [Event], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case nextToken = "NextToken"
        }
    }

    public struct ListInsightsAnyStatusFilter: AWSEncodableShape {
        ///  A time range used to specify when the behavior of the filtered insights started.
        public let startTimeRange: StartTimeRange
        ///  Use to filter for either REACTIVE or PROACTIVE insights.
        public let type: InsightType

        public init(startTimeRange: StartTimeRange, type: InsightType) {
            self.startTimeRange = startTimeRange
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case startTimeRange = "StartTimeRange"
            case type = "Type"
        }
    }

    public struct ListInsightsClosedStatusFilter: AWSEncodableShape {
        ///  A time range used to specify when the behavior of the filtered insights ended.
        public let endTimeRange: EndTimeRange
        ///  Use to filter for either REACTIVE or PROACTIVE insights.
        public let type: InsightType

        public init(endTimeRange: EndTimeRange, type: InsightType) {
            self.endTimeRange = endTimeRange
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case endTimeRange = "EndTimeRange"
            case type = "Type"
        }
    }

    public struct ListInsightsOngoingStatusFilter: AWSEncodableShape {
        ///  Use to filter for either REACTIVE or PROACTIVE insights.
        public let type: InsightType

        public init(type: InsightType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct ListInsightsRequest: AWSEncodableShape {
        /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        ///  A filter used to filter the returned insights by their status. You can specify one status filter.
        public let statusFilter: ListInsightsStatusFilter

        public init(maxResults: Int? = nil, nextToken: String? = nil, statusFilter: ListInsightsStatusFilter) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.statusFilter = statusFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case statusFilter = "StatusFilter"
        }
    }

    public struct ListInsightsResponse: AWSDecodableShape {
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        ///  The returned list of proactive insights.
        public let proactiveInsights: [ProactiveInsightSummary]?
        ///  The returned list of reactive insights.
        public let reactiveInsights: [ReactiveInsightSummary]?

        public init(nextToken: String? = nil, proactiveInsights: [ProactiveInsightSummary]? = nil, reactiveInsights: [ReactiveInsightSummary]? = nil) {
            self.nextToken = nextToken
            self.proactiveInsights = proactiveInsights
            self.reactiveInsights = reactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proactiveInsights = "ProactiveInsights"
            case reactiveInsights = "ReactiveInsights"
        }
    }

    public struct ListInsightsStatusFilter: AWSEncodableShape {
        ///  A ListInsightsAnyStatusFilter that specifies insights of any status that are either REACTIVE or PROACTIVE.
        public let any: ListInsightsAnyStatusFilter?
        ///  A ListInsightsClosedStatusFilter that specifies closed insights that are either REACTIVE or PROACTIVE.
        public let closed: ListInsightsClosedStatusFilter?
        ///  A ListInsightsAnyStatusFilter that specifies ongoing insights that are either REACTIVE or PROACTIVE.
        public let ongoing: ListInsightsOngoingStatusFilter?

        public init(any: ListInsightsAnyStatusFilter? = nil, closed: ListInsightsClosedStatusFilter? = nil, ongoing: ListInsightsOngoingStatusFilter? = nil) {
            self.any = any
            self.closed = closed
            self.ongoing = ongoing
        }

        private enum CodingKeys: String, CodingKey {
            case any = "Any"
            case closed = "Closed"
            case ongoing = "Ongoing"
        }
    }

    public struct ListNotificationChannelsRequest: AWSEncodableShape {
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct ListNotificationChannelsResponse: AWSDecodableShape {
        ///  An array that contains the requested notification channels.
        public let channels: [NotificationChannel]?
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        public init(channels: [NotificationChannel]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case nextToken = "NextToken"
        }
    }

    public struct ListRecommendationsRequest: AWSEncodableShape {
        ///  The ID of the requested insight.
        public let insightId: String
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        public init(insightId: String, nextToken: String? = nil) {
            self.insightId = insightId
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.insightId, name: "insightId", parent: name, max: 100)
            try self.validate(self.insightId, name: "insightId", parent: name, min: 1)
            try self.validate(self.insightId, name: "insightId", parent: name, pattern: "^[\\w-]*$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case insightId = "InsightId"
            case nextToken = "NextToken"
        }
    }

    public struct ListRecommendationsResponse: AWSDecodableShape {
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        ///  An array of the requested recommendations.
        public let recommendations: [Recommendation]?

        public init(nextToken: String? = nil, recommendations: [Recommendation]? = nil) {
            self.nextToken = nextToken
            self.recommendations = recommendations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case recommendations = "Recommendations"
        }
    }

    public struct NotificationChannel: AWSDecodableShape {
        ///  A NotificationChannelConfig object that contains information about configured notification channels.
        public let config: NotificationChannelConfig?
        ///  The ID of a notification channel.
        public let id: String?

        public init(config: NotificationChannelConfig? = nil, id: String? = nil) {
            self.config = config
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
            case id = "Id"
        }
    }

    public struct NotificationChannelConfig: AWSEncodableShape & AWSDecodableShape {
        ///  Information about a notification channel configured in DevOps Guru to send notifications when insights are created.  If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission to it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account. For more information, see Permissions for cross account Amazon SNS topics. If you use an Amazon SNS topic that is encrypted by an AWS Key Management Service customer-managed key (CMK), then you must add permissions to the CMK. For more information, see Permissions for AWS KMS–encrypted Amazon SNS topics.
        public let sns: SnsChannelConfig

        public init(sns: SnsChannelConfig) {
            self.sns = sns
        }

        public func validate(name: String) throws {
            try self.sns.validate(name: "\(name).sns")
        }

        private enum CodingKeys: String, CodingKey {
            case sns = "Sns"
        }
    }

    public struct OpsCenterIntegration: AWSDecodableShape {
        ///  Specifies if DevOps Guru is enabled to create an AWS Systems Manager OpsItem for each created insight.
        public let optInStatus: OptInStatus?

        public init(optInStatus: OptInStatus? = nil) {
            self.optInStatus = optInStatus
        }

        private enum CodingKeys: String, CodingKey {
            case optInStatus = "OptInStatus"
        }
    }

    public struct OpsCenterIntegrationConfig: AWSEncodableShape {
        ///  Specifies if DevOps Guru is enabled to create an AWS Systems Manager OpsItem for each created insight.
        public let optInStatus: OptInStatus?

        public init(optInStatus: OptInStatus? = nil) {
            self.optInStatus = optInStatus
        }

        private enum CodingKeys: String, CodingKey {
            case optInStatus = "OptInStatus"
        }
    }

    public struct PredictionTimeRange: AWSDecodableShape {
        ///  The time when the behavior in a proactive insight is expected to end.
        public let endTime: Date?
        ///  The time range during which a metric limit is expected to be exceeded. This applies to proactive insights only.
        public let startTime: Date

        public init(endTime: Date? = nil, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct ProactiveAnomaly: AWSDecodableShape {
        public let anomalyTimeRange: AnomalyTimeRange?
        ///  The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public let associatedInsightId: String?
        ///  The ID of a proactive anomaly.
        public let id: String?
        ///  A threshold that was exceeded by behavior in analyzed resources. Exceeding this threshold is related to the anomalous behavior that generated this anomaly.
        public let limit: Double?
        public let predictionTimeRange: PredictionTimeRange?
        public let resourceCollection: ResourceCollection?
        ///  The severity of a proactive anomaly.
        public let severity: AnomalySeverity?
        ///  Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public let sourceDetails: AnomalySourceDetails?
        ///  The status of a proactive anomaly.
        public let status: AnomalyStatus?
        ///  The time of the anomaly's most recent update.
        public let updateTime: Date?

        public init(anomalyTimeRange: AnomalyTimeRange? = nil, associatedInsightId: String? = nil, id: String? = nil, limit: Double? = nil, predictionTimeRange: PredictionTimeRange? = nil, resourceCollection: ResourceCollection? = nil, severity: AnomalySeverity? = nil, sourceDetails: AnomalySourceDetails? = nil, status: AnomalyStatus? = nil, updateTime: Date? = nil) {
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.id = id
            self.limit = limit
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyTimeRange = "AnomalyTimeRange"
            case associatedInsightId = "AssociatedInsightId"
            case id = "Id"
            case limit = "Limit"
            case predictionTimeRange = "PredictionTimeRange"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case sourceDetails = "SourceDetails"
            case status = "Status"
            case updateTime = "UpdateTime"
        }
    }

    public struct ProactiveAnomalySummary: AWSDecodableShape {
        public let anomalyTimeRange: AnomalyTimeRange?
        ///  The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public let associatedInsightId: String?
        /// The ID of the anomaly.
        public let id: String?
        ///  A threshold that was exceeded by behavior in analyzed resources. Exceeding this threshold is related to the anomalous behavior that generated this anomaly.
        public let limit: Double?
        public let predictionTimeRange: PredictionTimeRange?
        public let resourceCollection: ResourceCollection?
        /// The severity of the anomaly.
        public let severity: AnomalySeverity?
        ///  Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public let sourceDetails: AnomalySourceDetails?
        /// The status of the anomaly.
        public let status: AnomalyStatus?
        ///  The time of the anomaly's most recent update.
        public let updateTime: Date?

        public init(anomalyTimeRange: AnomalyTimeRange? = nil, associatedInsightId: String? = nil, id: String? = nil, limit: Double? = nil, predictionTimeRange: PredictionTimeRange? = nil, resourceCollection: ResourceCollection? = nil, severity: AnomalySeverity? = nil, sourceDetails: AnomalySourceDetails? = nil, status: AnomalyStatus? = nil, updateTime: Date? = nil) {
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.id = id
            self.limit = limit
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyTimeRange = "AnomalyTimeRange"
            case associatedInsightId = "AssociatedInsightId"
            case id = "Id"
            case limit = "Limit"
            case predictionTimeRange = "PredictionTimeRange"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case sourceDetails = "SourceDetails"
            case status = "Status"
            case updateTime = "UpdateTime"
        }
    }

    public struct ProactiveInsight: AWSDecodableShape {
        /// The ID of the proactive insight.
        public let id: String?
        public let insightTimeRange: InsightTimeRange?
        /// The name of the proactive insight.
        public let name: String?
        public let predictionTimeRange: PredictionTimeRange?
        public let resourceCollection: ResourceCollection?
        /// The severity of the proactive insight.
        public let severity: InsightSeverity?
        ///  The ID of the AWS System Manager OpsItem created for this insight. You must enable the creation of OpstItems insights before they are created for each insight.
        public let ssmOpsItemId: String?
        /// The status of the proactive insight.
        public let status: InsightStatus?

        public init(id: String? = nil, insightTimeRange: InsightTimeRange? = nil, name: String? = nil, predictionTimeRange: PredictionTimeRange? = nil, resourceCollection: ResourceCollection? = nil, severity: InsightSeverity? = nil, ssmOpsItemId: String? = nil, status: InsightStatus? = nil) {
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.ssmOpsItemId = ssmOpsItemId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case insightTimeRange = "InsightTimeRange"
            case name = "Name"
            case predictionTimeRange = "PredictionTimeRange"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case ssmOpsItemId = "SsmOpsItemId"
            case status = "Status"
        }
    }

    public struct ProactiveInsightSummary: AWSDecodableShape {
        /// The ID of the proactive insight.
        public let id: String?
        public let insightTimeRange: InsightTimeRange?
        /// The name of the proactive insight.
        public let name: String?
        public let predictionTimeRange: PredictionTimeRange?
        public let resourceCollection: ResourceCollection?
        /// The severity of the proactive insight.
        public let severity: InsightSeverity?
        /// The status of the proactive insight.
        public let status: InsightStatus?

        public init(id: String? = nil, insightTimeRange: InsightTimeRange? = nil, name: String? = nil, predictionTimeRange: PredictionTimeRange? = nil, resourceCollection: ResourceCollection? = nil, severity: InsightSeverity? = nil, status: InsightStatus? = nil) {
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case insightTimeRange = "InsightTimeRange"
            case name = "Name"
            case predictionTimeRange = "PredictionTimeRange"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case status = "Status"
        }
    }

    public struct PutFeedbackRequest: AWSEncodableShape {
        ///  The feedback from customers is about the recommendations in this insight.
        public let insightFeedback: InsightFeedback?

        public init(insightFeedback: InsightFeedback? = nil) {
            self.insightFeedback = insightFeedback
        }

        public func validate(name: String) throws {
            try self.insightFeedback?.validate(name: "\(name).insightFeedback")
        }

        private enum CodingKeys: String, CodingKey {
            case insightFeedback = "InsightFeedback"
        }
    }

    public struct PutFeedbackResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ReactiveAnomaly: AWSDecodableShape {
        public let anomalyTimeRange: AnomalyTimeRange?
        ///  The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public let associatedInsightId: String?
        /// The ID of the reactive anomaly.
        public let id: String?
        public let resourceCollection: ResourceCollection?
        /// The severity of the anomaly.
        public let severity: AnomalySeverity?
        ///  Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public let sourceDetails: AnomalySourceDetails?
        ///  The status of the anomaly.
        public let status: AnomalyStatus?

        public init(anomalyTimeRange: AnomalyTimeRange? = nil, associatedInsightId: String? = nil, id: String? = nil, resourceCollection: ResourceCollection? = nil, severity: AnomalySeverity? = nil, sourceDetails: AnomalySourceDetails? = nil, status: AnomalyStatus? = nil) {
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.id = id
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyTimeRange = "AnomalyTimeRange"
            case associatedInsightId = "AssociatedInsightId"
            case id = "Id"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case sourceDetails = "SourceDetails"
            case status = "Status"
        }
    }

    public struct ReactiveAnomalySummary: AWSDecodableShape {
        public let anomalyTimeRange: AnomalyTimeRange?
        ///  The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public let associatedInsightId: String?
        ///  The ID of the reactive anomaly.
        public let id: String?
        public let resourceCollection: ResourceCollection?
        ///  The severity of the reactive anomaly.
        public let severity: AnomalySeverity?
        ///  Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public let sourceDetails: AnomalySourceDetails?
        ///  The status of the reactive anomaly.
        public let status: AnomalyStatus?

        public init(anomalyTimeRange: AnomalyTimeRange? = nil, associatedInsightId: String? = nil, id: String? = nil, resourceCollection: ResourceCollection? = nil, severity: AnomalySeverity? = nil, sourceDetails: AnomalySourceDetails? = nil, status: AnomalyStatus? = nil) {
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.id = id
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case anomalyTimeRange = "AnomalyTimeRange"
            case associatedInsightId = "AssociatedInsightId"
            case id = "Id"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case sourceDetails = "SourceDetails"
            case status = "Status"
        }
    }

    public struct ReactiveInsight: AWSDecodableShape {
        ///  The ID of a reactive insight.
        public let id: String?
        public let insightTimeRange: InsightTimeRange?
        ///  The name of a reactive insight.
        public let name: String?
        public let resourceCollection: ResourceCollection?
        ///  The severity of a reactive insight.
        public let severity: InsightSeverity?
        ///  The ID of the AWS System Manager OpsItem created for this insight. You must enable the creation of OpstItems insights before they are created for each insight.
        public let ssmOpsItemId: String?
        ///  The status of a reactive insight.
        public let status: InsightStatus?

        public init(id: String? = nil, insightTimeRange: InsightTimeRange? = nil, name: String? = nil, resourceCollection: ResourceCollection? = nil, severity: InsightSeverity? = nil, ssmOpsItemId: String? = nil, status: InsightStatus? = nil) {
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.ssmOpsItemId = ssmOpsItemId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case insightTimeRange = "InsightTimeRange"
            case name = "Name"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case ssmOpsItemId = "SsmOpsItemId"
            case status = "Status"
        }
    }

    public struct ReactiveInsightSummary: AWSDecodableShape {
        ///  The ID of a reactive summary.
        public let id: String?
        public let insightTimeRange: InsightTimeRange?
        ///  The name of a reactive insight.
        public let name: String?
        public let resourceCollection: ResourceCollection?
        ///  The severity of a reactive insight.
        public let severity: InsightSeverity?
        ///  The status of a reactive insight.
        public let status: InsightStatus?

        public init(id: String? = nil, insightTimeRange: InsightTimeRange? = nil, name: String? = nil, resourceCollection: ResourceCollection? = nil, severity: InsightSeverity? = nil, status: InsightStatus? = nil) {
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case insightTimeRange = "InsightTimeRange"
            case name = "Name"
            case resourceCollection = "ResourceCollection"
            case severity = "Severity"
            case status = "Status"
        }
    }

    public struct Recommendation: AWSDecodableShape {
        ///  A description of the problem.
        public let description: String?
        ///  A hyperlink to information to help you address the problem.
        public let link: String?
        ///  The name of the recommendation.
        public let name: String?
        ///  The reason DevOps Guru flagged the anomalous behavior as a problem.
        public let reason: String?
        ///  Anomalies that are related to the problem. Use these Anomalies to learn more about what's happening and to help address the issue.
        public let relatedAnomalies: [RecommendationRelatedAnomaly]?
        ///  Events that are related to the problem. Use these events to learn more about what's happening and to help address the issue.
        public let relatedEvents: [RecommendationRelatedEvent]?

        public init(description: String? = nil, link: String? = nil, name: String? = nil, reason: String? = nil, relatedAnomalies: [RecommendationRelatedAnomaly]? = nil, relatedEvents: [RecommendationRelatedEvent]? = nil) {
            self.description = description
            self.link = link
            self.name = name
            self.reason = reason
            self.relatedAnomalies = relatedAnomalies
            self.relatedEvents = relatedEvents
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case link = "Link"
            case name = "Name"
            case reason = "Reason"
            case relatedAnomalies = "RelatedAnomalies"
            case relatedEvents = "RelatedEvents"
        }
    }

    public struct RecommendationRelatedAnomaly: AWSDecodableShape {
        ///  An array of objects that represent resources in which DevOps Guru detected anomalous behavior. Each object contains the name and type of the resource.
        public let resources: [RecommendationRelatedAnomalyResource]?
        ///  Information about where the anomalous behavior related the recommendation was found. For example, details in Amazon CloudWatch metrics.
        public let sourceDetails: [RecommendationRelatedAnomalySourceDetail]?

        public init(resources: [RecommendationRelatedAnomalyResource]? = nil, sourceDetails: [RecommendationRelatedAnomalySourceDetail]? = nil) {
            self.resources = resources
            self.sourceDetails = sourceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case resources = "Resources"
            case sourceDetails = "SourceDetails"
        }
    }

    public struct RecommendationRelatedAnomalyResource: AWSDecodableShape {
        ///  The name of the resource.
        public let name: String?
        ///  The type of the resource.
        public let type: String?

        public init(name: String? = nil, type: String? = nil) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct RecommendationRelatedAnomalySourceDetail: AWSDecodableShape {
        ///  An array of CloudWatchMetricsDetail objects that contains information about the analyzed metrics that displayed anomalous behavior.
        public let cloudWatchMetrics: [RecommendationRelatedCloudWatchMetricsSourceDetail]?

        public init(cloudWatchMetrics: [RecommendationRelatedCloudWatchMetricsSourceDetail]? = nil) {
            self.cloudWatchMetrics = cloudWatchMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchMetrics = "CloudWatchMetrics"
        }
    }

    public struct RecommendationRelatedCloudWatchMetricsSourceDetail: AWSDecodableShape {
        /// The name of the CloudWatch metric.
        public let metricName: String?
        /// The namespace of the CloudWatch metric. A namespace is a container for CloudWatch metrics.
        public let namespace: String?

        public init(metricName: String? = nil, namespace: String? = nil) {
            self.metricName = metricName
            self.namespace = namespace
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case namespace = "Namespace"
        }
    }

    public struct RecommendationRelatedEvent: AWSDecodableShape {
        ///  The name of the event. This corresponds to the Name field in an Event object.
        public let name: String?
        ///  A ResourceCollection object that contains arrays of the names of AWS CloudFormation stacks.
        public let resources: [RecommendationRelatedEventResource]?

        public init(name: String? = nil, resources: [RecommendationRelatedEventResource]? = nil) {
            self.name = name
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case resources = "Resources"
        }
    }

    public struct RecommendationRelatedEventResource: AWSDecodableShape {
        ///  The name of the resource that emitted the event. This corresponds to the Name field in an EventResource object.
        public let name: String?
        ///  The type of the resource that emitted the event. This corresponds to the Type field in an EventResource object.
        public let type: String?

        public init(name: String? = nil, type: String? = nil) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct RemoveNotificationChannelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "Id"))
        ]

        ///  The ID of the notification channel to be removed.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveNotificationChannelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ResourceCollection: AWSEncodableShape & AWSDecodableShape {
        ///  An array of the names of AWS CloudFormation stacks. The stacks define AWS resources that DevOps Guru analyzes.
        public let cloudFormation: CloudFormationCollection?

        public init(cloudFormation: CloudFormationCollection? = nil) {
            self.cloudFormation = cloudFormation
        }

        public func validate(name: String) throws {
            try self.cloudFormation?.validate(name: "\(name).cloudFormation")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "CloudFormation"
        }
    }

    public struct ResourceCollectionFilter: AWSDecodableShape {
        ///  Information about AWS CloudFormation stacks. You can use stacks to specify which AWS resources in your account to analyze. For more information, see Stacks in the AWS CloudFormation User Guide.
        public let cloudFormation: CloudFormationCollectionFilter?

        public init(cloudFormation: CloudFormationCollectionFilter? = nil) {
            self.cloudFormation = cloudFormation
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "CloudFormation"
        }
    }

    public struct SearchInsightsFilters: AWSEncodableShape {
        public let resourceCollection: ResourceCollection?
        ///  An array of severity values used to search for insights.
        public let severities: [InsightSeverity]?
        ///  An array of status values used to search for insights.
        public let statuses: [InsightStatus]?

        public init(resourceCollection: ResourceCollection? = nil, severities: [InsightSeverity]? = nil, statuses: [InsightStatus]? = nil) {
            self.resourceCollection = resourceCollection
            self.severities = severities
            self.statuses = statuses
        }

        public func validate(name: String) throws {
            try self.resourceCollection?.validate(name: "\(name).resourceCollection")
            try self.validate(self.severities, name: "severities", parent: name, max: 3)
            try self.validate(self.severities, name: "severities", parent: name, min: 0)
            try self.validate(self.statuses, name: "statuses", parent: name, max: 2)
            try self.validate(self.statuses, name: "statuses", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceCollection = "ResourceCollection"
            case severities = "Severities"
            case statuses = "Statuses"
        }
    }

    public struct SearchInsightsRequest: AWSEncodableShape {
        ///  A SearchInsightsFilters object that is used to set the severity and status filters on your insight search.
        public let filters: SearchInsightsFilters?
        /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        ///  The start of the time range passed in. Returned insights occurred after this time.
        public let startTimeRange: StartTimeRange
        ///  The type of insights you are searching for (REACTIVE or PROACTIVE).
        public let type: InsightType

        public init(filters: SearchInsightsFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, startTimeRange: StartTimeRange, type: InsightType) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTimeRange = startTimeRange
            self.type = type
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 36)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTimeRange = "StartTimeRange"
            case type = "Type"
        }
    }

    public struct SearchInsightsResponse: AWSDecodableShape {
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        ///  The returned proactive insights.
        public let proactiveInsights: [ProactiveInsightSummary]?
        ///  The returned reactive insights.
        public let reactiveInsights: [ReactiveInsightSummary]?

        public init(nextToken: String? = nil, proactiveInsights: [ProactiveInsightSummary]? = nil, reactiveInsights: [ReactiveInsightSummary]? = nil) {
            self.nextToken = nextToken
            self.proactiveInsights = proactiveInsights
            self.reactiveInsights = reactiveInsights
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proactiveInsights = "ProactiveInsights"
            case reactiveInsights = "ReactiveInsights"
        }
    }

    public struct ServiceIntegrationConfig: AWSDecodableShape {
        ///  Information about whether DevOps Guru is configured to create an OpsItem in AWS Systems Manager OpsCenter for each created insight.
        public let opsCenter: OpsCenterIntegration?

        public init(opsCenter: OpsCenterIntegration? = nil) {
            self.opsCenter = opsCenter
        }

        private enum CodingKeys: String, CodingKey {
            case opsCenter = "OpsCenter"
        }
    }

    public struct SnsChannelConfig: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of an Amazon Simple Notification Service topic.
        public let topicArn: String?

        public init(topicArn: String? = nil) {
            self.topicArn = topicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.topicArn, name: "topicArn", parent: name, max: 1024)
            try self.validate(self.topicArn, name: "topicArn", parent: name, min: 36)
            try self.validate(self.topicArn, name: "topicArn", parent: name, pattern: "^arn:aws[a-z0-9-]*:sns:[a-z0-9-]+:\\d{12}:[^:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case topicArn = "TopicArn"
        }
    }

    public struct StartTimeRange: AWSEncodableShape {
        ///  The start time of the time range.
        public let fromTime: Date?
        ///  The end time of the time range.
        public let toTime: Date?

        public init(fromTime: Date? = nil, toTime: Date? = nil) {
            self.fromTime = fromTime
            self.toTime = toTime
        }

        private enum CodingKeys: String, CodingKey {
            case fromTime = "FromTime"
            case toTime = "ToTime"
        }
    }

    public struct UpdateCloudFormationCollectionFilter: AWSEncodableShape {
        ///  An array of the name of stacks to update.
        public let stackNames: [String]?

        public init(stackNames: [String]? = nil) {
            self.stackNames = stackNames
        }

        public func validate(name: String) throws {
            try self.stackNames?.forEach {
                try validate($0, name: "stackNames[]", parent: name, max: 128)
                try validate($0, name: "stackNames[]", parent: name, min: 1)
                try validate($0, name: "stackNames[]", parent: name, pattern: "^[a-zA-Z*]+[a-zA-Z0-9-]*$")
            }
            try self.validate(self.stackNames, name: "stackNames", parent: name, max: 100)
            try self.validate(self.stackNames, name: "stackNames", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case stackNames = "StackNames"
        }
    }

    public struct UpdateResourceCollectionFilter: AWSEncodableShape {
        ///  An collection of AWS CloudFormation stacks.
        public let cloudFormation: UpdateCloudFormationCollectionFilter?

        public init(cloudFormation: UpdateCloudFormationCollectionFilter? = nil) {
            self.cloudFormation = cloudFormation
        }

        public func validate(name: String) throws {
            try self.cloudFormation?.validate(name: "\(name).cloudFormation")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "CloudFormation"
        }
    }

    public struct UpdateResourceCollectionRequest: AWSEncodableShape {
        ///  Specifies if the resource collection in the request is added or deleted to the resource collection.
        public let action: UpdateResourceCollectionAction
        public let resourceCollection: UpdateResourceCollectionFilter

        public init(action: UpdateResourceCollectionAction, resourceCollection: UpdateResourceCollectionFilter) {
            self.action = action
            self.resourceCollection = resourceCollection
        }

        public func validate(name: String) throws {
            try self.resourceCollection.validate(name: "\(name).resourceCollection")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case resourceCollection = "ResourceCollection"
        }
    }

    public struct UpdateResourceCollectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateServiceIntegrationConfig: AWSEncodableShape {
        public let opsCenter: OpsCenterIntegrationConfig?

        public init(opsCenter: OpsCenterIntegrationConfig? = nil) {
            self.opsCenter = opsCenter
        }

        private enum CodingKeys: String, CodingKey {
            case opsCenter = "OpsCenter"
        }
    }

    public struct UpdateServiceIntegrationRequest: AWSEncodableShape {
        ///  An IntegratedServiceConfig object used to specify the integrated service you want to update, and whether you want to update it to enabled or disabled.
        public let serviceIntegration: UpdateServiceIntegrationConfig

        public init(serviceIntegration: UpdateServiceIntegrationConfig) {
            self.serviceIntegration = serviceIntegration
        }

        private enum CodingKeys: String, CodingKey {
            case serviceIntegration = "ServiceIntegration"
        }
    }

    public struct UpdateServiceIntegrationResponse: AWSDecodableShape {
        public init() {}
    }
}
