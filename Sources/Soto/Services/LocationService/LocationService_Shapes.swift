//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension LocationService {
    // MARK: Enums

    public enum BatchItemErrorCode: String, CustomStringConvertible, Codable {
        case accessdeniederror = "AccessDeniedError"
        case conflicterror = "ConflictError"
        case internalservererror = "InternalServerError"
        case resourcenotfounderror = "ResourceNotFoundError"
        case throttlingerror = "ThrottlingError"
        case validationerror = "ValidationError"
        public var description: String { return self.rawValue }
    }

    public enum IntendedUse: String, CustomStringConvertible, Codable {
        case singleuse = "SingleUse"
        case storage = "Storage"
        public var description: String { return self.rawValue }
    }

    public enum PricingPlan: String, CustomStringConvertible, Codable {
        case mobileassetmanagement = "MobileAssetManagement"
        case mobileassettracking = "MobileAssetTracking"
        case requestbasedusage = "RequestBasedUsage"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociateTrackerConsumerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker resource. Used when you need to specify a resource across all AWS.    Format example: arn:partition:service:region:account-id:resource-type:resource-id
        public let consumerArn: String
        /// The name of the tracker resource to be associated with a geofence collection.
        public let trackerName: String

        public init(consumerArn: String, trackerName: String) {
            self.consumerArn = consumerArn
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, max: 1600)
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, min: 0)
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case consumerArn = "ConsumerArn"
        }
    }

    public struct AssociateTrackerConsumerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct BatchDeleteGeofenceError: AWSDecodableShape {
        /// Contains details associated to the batch error.
        public let error: BatchItemError
        /// The geofence associated with the error message.
        public let geofenceId: String

        public init(error: BatchItemError, geofenceId: String) {
            self.error = error
            self.geofenceId = geofenceId
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case geofenceId = "GeofenceId"
        }
    }

    public struct BatchDeleteGeofenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The geofence collection storing the geofences to be deleted.
        public let collectionName: String
        /// The batch of geofences to be deleted.
        public let geofenceIds: [String]

        public init(collectionName: String, geofenceIds: [String]) {
            self.collectionName = collectionName
            self.geofenceIds = geofenceIds
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.geofenceIds.forEach {
                try validate($0, name: "geofenceIds[]", parent: name, max: 100)
                try validate($0, name: "geofenceIds[]", parent: name, min: 1)
                try validate($0, name: "geofenceIds[]", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            }
            try self.validate(self.geofenceIds, name: "geofenceIds", parent: name, max: 10)
            try self.validate(self.geofenceIds, name: "geofenceIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case geofenceIds = "GeofenceIds"
        }
    }

    public struct BatchDeleteGeofenceResponse: AWSDecodableShape {
        /// Contains error details for each geofence that failed to delete.
        public let errors: [BatchDeleteGeofenceError]

        public init(errors: [BatchDeleteGeofenceError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchEvaluateGeofencesError: AWSDecodableShape {
        /// The device associated with the position evaluation error.
        public let deviceId: String
        /// Contains details associated to the batch error.
        public let error: BatchItemError
        /// Specifies a timestamp for when the error occurred in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String, error: BatchItemError, sampleTime: Date) {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
            case sampleTime = "SampleTime"
        }
    }

    public struct BatchEvaluateGeofencesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The geofence collection used in evaluating the position of devices against its geofences.
        public let collectionName: String
        /// Contains device details for each device to be evaluated against the given geofence collection.
        public let devicePositionUpdates: [DevicePositionUpdate]

        public init(collectionName: String, devicePositionUpdates: [DevicePositionUpdate]) {
            self.collectionName = collectionName
            self.devicePositionUpdates = devicePositionUpdates
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.devicePositionUpdates.forEach {
                try $0.validate(name: "\(name).devicePositionUpdates[]")
            }
            try self.validate(self.devicePositionUpdates, name: "devicePositionUpdates", parent: name, max: 10)
            try self.validate(self.devicePositionUpdates, name: "devicePositionUpdates", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case devicePositionUpdates = "DevicePositionUpdates"
        }
    }

    public struct BatchEvaluateGeofencesResponse: AWSDecodableShape {
        /// Contains error details for each device that failed to evaluate its position against the given geofence collection.
        public let errors: [BatchEvaluateGeofencesError]

        public init(errors: [BatchEvaluateGeofencesError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchGetDevicePositionError: AWSDecodableShape {
        /// The ID of the device that didn't return a position.
        public let deviceId: String
        /// Contains details related to the error code.
        public let error: BatchItemError

        public init(deviceId: String, error: BatchItemError) {
            self.deviceId = deviceId
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
        }
    }

    public struct BatchGetDevicePositionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// Devices whose position you want to retrieve.   For example, for two devices: device-ids=DeviceId1&amp;device-ids=DeviceId2
        public let deviceIds: [String]
        /// The tracker resource retrieving the device position.
        public let trackerName: String

        public init(deviceIds: [String], trackerName: String) {
            self.deviceIds = deviceIds
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.deviceIds.forEach {
                try validate($0, name: "deviceIds[]", parent: name, max: 100)
                try validate($0, name: "deviceIds[]", parent: name, min: 1)
                try validate($0, name: "deviceIds[]", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            }
            try self.validate(self.deviceIds, name: "deviceIds", parent: name, max: 10)
            try self.validate(self.deviceIds, name: "deviceIds", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceIds = "DeviceIds"
        }
    }

    public struct BatchGetDevicePositionResponse: AWSDecodableShape {
        /// Contains device position details such as the device ID, position, and timestamps for when the position was received and sampled.
        public let devicePositions: [DevicePosition]
        /// Contains error details for each device that failed to send its position to the tracker resource.
        public let errors: [BatchGetDevicePositionError]

        public init(devicePositions: [DevicePosition], errors: [BatchGetDevicePositionError]) {
            self.devicePositions = devicePositions
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case devicePositions = "DevicePositions"
            case errors = "Errors"
        }
    }

    public struct BatchItemError: AWSDecodableShape {
        /// The error code associated with the batch request error.
        public let code: BatchItemErrorCode?
        /// A message with the reason for the batch request error.
        public let message: String?

        public init(code: BatchItemErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct BatchPutGeofenceError: AWSDecodableShape {
        /// Contains details associated to the batch error.
        public let error: BatchItemError
        /// The geofence associated with the error message.
        public let geofenceId: String

        public init(error: BatchItemError, geofenceId: String) {
            self.error = error
            self.geofenceId = geofenceId
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case geofenceId = "GeofenceId"
        }
    }

    public struct BatchPutGeofenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The geofence collection storing the geofences.
        public let collectionName: String
        /// The batch of geofences to be stored in a geofence collection.
        public let entries: [BatchPutGeofenceRequestEntry]

        public init(collectionName: String, entries: [BatchPutGeofenceRequestEntry]) {
            self.collectionName = collectionName
            self.entries = entries
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.entries, name: "entries", parent: name, max: 10)
            try self.validate(self.entries, name: "entries", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
        }
    }

    public struct BatchPutGeofenceRequestEntry: AWSEncodableShape {
        /// The identifier for the geofence to be stored in a given geofence collection.
        public let geofenceId: String
        /// The geometry details for the geofence.
        public let geometry: GeofenceGeometry

        public init(geofenceId: String, geometry: GeofenceGeometry) {
            self.geofenceId = geofenceId
            self.geometry = geometry
        }

        public func validate(name: String) throws {
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, max: 100)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, min: 1)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.geometry.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case geofenceId = "GeofenceId"
            case geometry = "Geometry"
        }
    }

    public struct BatchPutGeofenceResponse: AWSDecodableShape {
        /// Contains additional error details for each geofence that failed to be stored in a geofence collection.
        public let errors: [BatchPutGeofenceError]
        /// Contains each geofence that was successfully stored in a geofence collection.
        public let successes: [BatchPutGeofenceSuccess]

        public init(errors: [BatchPutGeofenceError], successes: [BatchPutGeofenceSuccess]) {
            self.errors = errors
            self.successes = successes
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case successes = "Successes"
        }
    }

    public struct BatchPutGeofenceSuccess: AWSDecodableShape {
        /// The timestamp for when the geofence was stored in a geofence collection in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence successfully stored in a geofence collection.
        public let geofenceId: String
        /// The timestamp for when the geofence was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, geofenceId: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case updateTime = "UpdateTime"
        }
    }

    public struct BatchUpdateDevicePositionError: AWSDecodableShape {
        /// The device associated with the failed location update.
        public let deviceId: String
        /// Contains details related to the error code such as the error code and error message.
        public let error: BatchItemError
        /// The timestamp for when a position sample was attempted in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String, error: BatchItemError, sampleTime: Date) {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case error = "Error"
            case sampleTime = "SampleTime"
        }
    }

    public struct BatchUpdateDevicePositionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The name of the tracker resource to update.
        public let trackerName: String
        /// Contains the position update details for each device.
        public let updates: [DevicePositionUpdate]

        public init(trackerName: String, updates: [DevicePositionUpdate]) {
            self.trackerName = trackerName
            self.updates = updates
        }

        public func validate(name: String) throws {
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
            try self.updates.forEach {
                try $0.validate(name: "\(name).updates[]")
            }
            try self.validate(self.updates, name: "updates", parent: name, max: 10)
            try self.validate(self.updates, name: "updates", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case updates = "Updates"
        }
    }

    public struct BatchUpdateDevicePositionResponse: AWSDecodableShape {
        /// Contains error details for each device that failed to update its position.
        public let errors: [BatchUpdateDevicePositionError]

        public init(errors: [BatchUpdateDevicePositionError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct CreateGeofenceCollectionRequest: AWSEncodableShape {
        /// A custom name for the geofence collection. Requirements:   Contain only alphanumeric characters (A–Z, a–z, 0-9), hyphens (-), and underscores (_).    Must be a unique geofence collection name.   No spaces allowed. For example, ExampleGeofenceCollection.
        public let collectionName: String
        /// An optional description for the geofence collection.
        public let description: String?
        /// Specifies the pricing plan for your geofence collection. There's three pricing plan options:    RequestBasedUsage — Selects the "Request-Based Usage" pricing plan.    MobileAssetTracking — Selects the "Mobile Asset Tracking" pricing plan.    MobileAssetManagement — Selects the "Mobile Asset Management" pricing plan.   For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan

        public init(collectionName: String, description: String? = nil, pricingPlan: PricingPlan) {
            self.collectionName = collectionName
            self.description = description
            self.pricingPlan = pricingPlan
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case collectionName = "CollectionName"
            case description = "Description"
            case pricingPlan = "PricingPlan"
        }
    }

    public struct CreateGeofenceCollectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all AWS.
        public let collectionArn: String
        /// The name for the geofence collection.
        public let collectionName: String
        /// The timestamp for when the geofence collection was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date

        public init(collectionArn: String, collectionName: String, createTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.createTime = createTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "CollectionArn"
            case collectionName = "CollectionName"
            case createTime = "CreateTime"
        }
    }

    public struct CreateMapRequest: AWSEncodableShape {
        /// Specifies the map style selected from an available data provider.
        public let configuration: MapConfiguration
        /// An optional description for the map resource.
        public let description: String?
        /// The name for the map resource. Requirements:   Must contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), and underscores (_).    Must be a unique map resource name.    No spaces allowed. For example, ExampleMap.
        public let mapName: String
        /// Specifies the pricing plan for your map resource. There's three pricing plan options:    RequestBasedUsage — Selects the "Request-Based Usage" pricing plan.    MobileAssetTracking — Selects the "Mobile Asset Tracking" pricing plan.    MobileAssetManagement — Selects the "Mobile Asset Management" pricing plan.   For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan

        public init(configuration: MapConfiguration, description: String? = nil, mapName: String, pricingPlan: PricingPlan) {
            self.configuration = configuration
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case description = "Description"
            case mapName = "MapName"
            case pricingPlan = "PricingPlan"
        }
    }

    public struct CreateMapResponse: AWSDecodableShape {
        /// The timestamp for when the map resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The Amazon Resource Name (ARN) for the map resource. Used when you need to specify a resource across all AWS.   Format example: arn:partition:service:region:account-id:resource-type:resource-id
        public let mapArn: String
        /// The name of the map resource.
        public let mapName: String

        public init(createTime: Date, mapArn: String, mapName: String) {
            self.createTime = createTime
            self.mapArn = mapArn
            self.mapName = mapName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case mapArn = "MapArn"
            case mapName = "MapName"
        }
    }

    public struct CreatePlaceIndexRequest: AWSEncodableShape {
        /// Specifies the data provider of geospatial data.
        public let dataSource: String
        /// Specifies the data storage option for requesting Places.
        public let dataSourceConfiguration: DataSourceConfiguration?
        /// The optional description for the Place index resource.
        public let description: String?
        /// The name of the Place index resource.  Requirements:   Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-) and underscores (_) ).   Must be a unique Place index resource name.   No spaces allowed. For example, ExamplePlaceIndex.
        public let indexName: String
        /// Specifies the pricing plan for your Place index resource. There's three pricing plan options:    RequestBasedUsage — Selects the "Request-Based Usage" pricing plan.    MobileAssetTracking — Selects the "Mobile Asset Tracking" pricing plan.    MobileAssetManagement — Selects the "Mobile Asset Management" pricing plan.   For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan

        public init(dataSource: String, dataSourceConfiguration: DataSourceConfiguration? = nil, description: String? = nil, indexName: String, pricingPlan: PricingPlan) {
            self.dataSource = dataSource
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case dataSourceConfiguration = "DataSourceConfiguration"
            case description = "Description"
            case indexName = "IndexName"
            case pricingPlan = "PricingPlan"
        }
    }

    public struct CreatePlaceIndexResponse: AWSDecodableShape {
        /// The timestamp for when the Place index resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The Amazon Resource Name (ARN) for the Place index resource. Used when you need to specify a resource across all AWS.
        public let indexArn: String
        /// The name for the Place index resource.
        public let indexName: String

        public init(createTime: Date, indexArn: String, indexName: String) {
            self.createTime = createTime
            self.indexArn = indexArn
            self.indexName = indexName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case indexArn = "IndexArn"
            case indexName = "IndexName"
        }
    }

    public struct CreateTrackerRequest: AWSEncodableShape {
        /// An optional description for the tracker resource.
        public let description: String?
        /// Specifies the pricing plan for your tracker resource. There's three pricing plan options:    RequestBasedUsage — Selects the "Request-Based Usage" pricing plan.    MobileAssetTracking — Selects the "Mobile Asset Tracking" pricing plan.    MobileAssetManagement — Selects the "Mobile Asset Management" pricing plan.   For additional details and restrictions on each pricing plan option, see the Amazon Location Service pricing page.
        public let pricingPlan: PricingPlan
        /// The name for the tracker resource. Requirements:   Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-) and underscores (_).   Must be a unique tracker resource name.   No spaces allowed. For example, ExampleTracker.
        public let trackerName: String

        public init(description: String? = nil, pricingPlan: PricingPlan, trackerName: String) {
            self.description = description
            self.pricingPlan = pricingPlan
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case pricingPlan = "PricingPlan"
            case trackerName = "TrackerName"
        }
    }

    public struct CreateTrackerResponse: AWSDecodableShape {
        /// The timestamp for when the tracker resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all AWS.
        public let trackerArn: String
        /// The name of the tracker resource.
        public let trackerName: String

        public init(createTime: Date, trackerArn: String, trackerName: String) {
            self.createTime = createTime
            self.trackerArn = trackerArn
            self.trackerName = trackerName
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case trackerArn = "TrackerArn"
            case trackerName = "TrackerName"
        }
    }

    public struct DataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how the results of an operation will be stored by the caller.  Valid values include:    SingleUse specifies that the results won't be stored.     Storage specifies that the result can be cached or stored in a database.   Default value: SingleUse
        public let intendedUse: IntendedUse?

        public init(intendedUse: IntendedUse? = nil) {
            self.intendedUse = intendedUse
        }

        private enum CodingKeys: String, CodingKey {
            case intendedUse = "IntendedUse"
        }
    }

    public struct DeleteGeofenceCollectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The name of the geofence collection to be deleted.
        public let collectionName: String

        public init(collectionName: String) {
            self.collectionName = collectionName
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGeofenceCollectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMapRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName"))
        ]

        /// The name of the map resource to be deleted.
        public let mapName: String

        public init(mapName: String) {
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMapResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePlaceIndexRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri(locationName: "IndexName"))
        ]

        /// The name of the Place index resource to be deleted.
        public let indexName: String

        public init(indexName: String) {
            self.indexName = indexName
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePlaceIndexResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTrackerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The name of the tracker resource to be deleted.
        public let trackerName: String

        public init(trackerName: String) {
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTrackerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeGeofenceCollectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The name of the geofence collection.
        public let collectionName: String

        public init(collectionName: String) {
            self.collectionName = collectionName
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGeofenceCollectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you need to specify a resource across all AWS.
        public let collectionArn: String
        /// The name of the geofence collection.
        public let collectionName: String
        /// The timestamp for when the geofence resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The optional description for the geofence collection.
        public let description: String
        /// The timestamp for when the geofence collection was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(collectionArn: String, collectionName: String, createTime: Date, description: String, updateTime: Date) {
            self.collectionArn = collectionArn
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionArn = "CollectionArn"
            case collectionName = "CollectionName"
            case createTime = "CreateTime"
            case description = "Description"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribeMapRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName"))
        ]

        /// The name of the map resource.
        public let mapName: String

        public init(mapName: String) {
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeMapResponse: AWSDecodableShape {
        /// Specifies the map tile style selected from a partner data provider.
        public let configuration: MapConfiguration
        /// The timestamp for when the map resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// Specifies the data provider for the associated map tiles.
        public let dataSource: String
        /// The optional description for the map resource.
        public let description: String
        /// The Amazon Resource Name (ARN) for the map resource. Used when you need to specify a resource across all AWS.
        public let mapArn: String
        /// The map style selected from an available provider.
        public let mapName: String
        /// The timestamp for when the map resource was last update in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(configuration: MapConfiguration, createTime: Date, dataSource: String, description: String, mapArn: String, mapName: String, updateTime: Date) {
            self.configuration = configuration
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapArn = mapArn
            self.mapName = mapName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case mapArn = "MapArn"
            case mapName = "MapName"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribePlaceIndexRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri(locationName: "IndexName"))
        ]

        /// The name of the Place index resource.
        public let indexName: String

        public init(indexName: String) {
            self.indexName = indexName
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePlaceIndexResponse: AWSDecodableShape {
        /// The timestamp for when the Place index resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of geospatial data.
        public let dataSource: String
        /// The specified data storage option for requesting Places.
        public let dataSourceConfiguration: DataSourceConfiguration
        /// The optional description for the Place index resource.
        public let description: String
        /// The Amazon Resource Name (ARN) for the Place index resource. Used when you need to specify a resource across all AWS.
        public let indexArn: String
        /// The name of the Place index resource being described.
        public let indexName: String
        /// The timestamp for when the Place index resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, dataSource: String, dataSourceConfiguration: DataSourceConfiguration, description: String, indexArn: String, indexName: String, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.dataSourceConfiguration = dataSourceConfiguration
            self.description = description
            self.indexArn = indexArn
            self.indexName = indexName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case dataSourceConfiguration = "DataSourceConfiguration"
            case description = "Description"
            case indexArn = "IndexArn"
            case indexName = "IndexName"
            case updateTime = "UpdateTime"
        }
    }

    public struct DescribeTrackerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The name of the tracker resource.
        public let trackerName: String

        public init(trackerName: String) {
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTrackerResponse: AWSDecodableShape {
        /// The timestamp for when the tracker resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The optional description for the tracker resource.
        public let description: String
        /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify a resource across all AWS.
        public let trackerArn: String
        /// The name of the tracker resource.
        public let trackerName: String
        /// The timestamp for when the tracker resource was last updated in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, description: String, trackerArn: String, trackerName: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.trackerArn = trackerArn
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case description = "Description"
            case trackerArn = "TrackerArn"
            case trackerName = "TrackerName"
            case updateTime = "UpdateTime"
        }
    }

    public struct DevicePosition: AWSDecodableShape {
        /// The device whose position you retrieved.
        public let deviceId: String?
        /// The last known device position.
        public let position: [Double]
        /// The timestamp for when the tracker resource recieved the position in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var receivedTime: Date
        /// The timestamp for when the position was detected and sampled in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String? = nil, position: [Double], receivedTime: Date, sampleTime: Date) {
            self.deviceId = deviceId
            self.position = position
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case position = "Position"
            case receivedTime = "ReceivedTime"
            case sampleTime = "SampleTime"
        }
    }

    public struct DevicePositionUpdate: AWSEncodableShape {
        /// The device associated to the position update.
        public let deviceId: String
        /// The latest device position defined in WGS 84 format: [Xlongitude, Ylatitude].
        public let position: [Double]
        /// The timestamp for when the position update was received in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String, position: [Double], sampleTime: Date) {
            self.deviceId = deviceId
            self.position = position
            self.sampleTime = sampleTime
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case position = "Position"
            case sampleTime = "SampleTime"
        }
    }

    public struct DisassociateTrackerConsumerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "consumerArn", location: .uri(locationName: "ConsumerArn")),
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The Amazon Resource Name (ARN) for the geofence collection to be disassociated from the tracker resource. Used when you need to specify a resource across all AWS.    Format example: arn:partition:service:region:account-id:resource-type:resource-id
        public let consumerArn: String
        /// The name of the tracker resource to be dissociated from the consumer.
        public let trackerName: String

        public init(consumerArn: String, trackerName: String) {
            self.consumerArn = consumerArn
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, max: 1600)
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, min: 0)
            try self.validate(self.consumerArn, name: "consumerArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateTrackerConsumerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GeofenceGeometry: AWSEncodableShape & AWSDecodableShape {
        /// An array of 1 or more linear rings. A linear ring is an array of 4 or more vertices, where the first and last vertex are the same to form a closed boundary. Each vertex is a 2-dimensional point of the form: [longitude, latitude].  The first linear ring is an outer ring, describing the polygon's boundary. Subsequent linear rings may be inner or outer rings to describe holes and islands. Outer rings must list their vertices in counter-clockwise order around the ring's center, where the left side is the polygon's exterior. Inner rings must list their vertices in clockwise order, where the left side is the polygon's interior.
        public let polygon: [[[Double]]]?

        public init(polygon: [[[Double]]]? = nil) {
            self.polygon = polygon
        }

        public func validate(name: String) throws {
            try self.polygon?.forEach {
                try validate($0, name: "polygon[]", parent: name, min: 4)
            }
            try self.validate(self.polygon, name: "polygon", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case polygon = "Polygon"
        }
    }

    public struct GetDevicePositionHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "deviceId", location: .uri(locationName: "DeviceId")),
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The device whose position history you want to retrieve.
        public let deviceId: String
        /// Specify the end time for the position history in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    The given time for EndTimeExclusive must be after the time for StartTimeInclusive.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTimeExclusive: Date?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?
        /// Specify the start time for the position history in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.    The given time for EndTimeExclusive must be after the time for StartTimeInclusive.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTimeInclusive: Date?
        /// The tracker resource receiving the request for the device position history.
        public let trackerName: String

        public init(deviceId: String, endTimeExclusive: Date? = nil, nextToken: String? = nil, startTimeInclusive: Date? = nil, trackerName: String) {
            self.deviceId = deviceId
            self.endTimeExclusive = endTimeExclusive
            self.nextToken = nextToken
            self.startTimeInclusive = startTimeInclusive
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTimeExclusive = "EndTimeExclusive"
            case nextToken = "NextToken"
            case startTimeInclusive = "StartTimeInclusive"
        }
    }

    public struct GetDevicePositionHistoryResponse: AWSDecodableShape {
        /// Contains the position history details for the requested device.
        public let devicePositions: [DevicePosition]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(devicePositions: [DevicePosition], nextToken: String? = nil) {
            self.devicePositions = devicePositions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devicePositions = "DevicePositions"
            case nextToken = "NextToken"
        }
    }

    public struct GetDevicePositionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "deviceId", location: .uri(locationName: "DeviceId")),
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// The device whose position you want to retreieve.
        public let deviceId: String
        /// The tracker resource receiving the position update.
        public let trackerName: String

        public init(deviceId: String, trackerName: String) {
            self.deviceId = deviceId
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 100)
            try self.validate(self.deviceId, name: "deviceId", parent: name, min: 1)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDevicePositionResponse: AWSDecodableShape {
        /// The device whose position you retrieved.
        public let deviceId: String?
        /// The last known device position.
        public let position: [Double]
        /// The timestamp for when the tracker resource recieved the position in  ISO 8601  format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var receivedTime: Date
        /// The timestamp for when the position was detected and sampled in  ISO 8601  format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var sampleTime: Date

        public init(deviceId: String? = nil, position: [Double], receivedTime: Date, sampleTime: Date) {
            self.deviceId = deviceId
            self.position = position
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case position = "Position"
            case receivedTime = "ReceivedTime"
            case sampleTime = "SampleTime"
        }
    }

    public struct GetGeofenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName")),
            AWSMemberEncoding(label: "geofenceId", location: .uri(locationName: "GeofenceId"))
        ]

        /// The geofence collection storing the target geofence.
        public let collectionName: String
        /// The geofence you're retrieving details for.
        public let geofenceId: String

        public init(collectionName: String, geofenceId: String) {
            self.collectionName = collectionName
            self.geofenceId = geofenceId
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, max: 100)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, min: 1)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGeofenceResponse: AWSDecodableShape {
        /// The timestamp for when the geofence collection was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence identifier.
        public let geofenceId: String
        /// Contains the geofence geometry details describing a polygon.
        public let geometry: GeofenceGeometry
        /// Identifies the state of the geofence. A geofence will hold one of the following states:    ACTIVE — The geofence has been indexed by the system.     PENDING — The geofence is being processed by the system.    FAILED — The geofence failed to be indexed by the system.    DELETED — The geofence has been deleted from the system index.    DELETING — The geofence is being deleted from the system index.
        public let status: String
        /// The timestamp for when the geofence collection was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, geofenceId: String, geometry: GeofenceGeometry, status: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.geometry = geometry
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case geometry = "Geometry"
            case status = "Status"
            case updateTime = "UpdateTime"
        }
    }

    public struct GetMapGlyphsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "fontStack", location: .uri(locationName: "FontStack")),
            AWSMemberEncoding(label: "fontUnicodeRange", location: .uri(locationName: "FontUnicodeRange")),
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName"))
        ]

        /// A comma-separated list of fonts to load glyphs from in order of preference.. For example, Noto Sans, Arial Unicode.
        public let fontStack: String
        /// A Unicode range of characters to download glyphs for. Each response will contain 256 characters. For example, 0-255 includes all characters from range U+0000 to 00FF. Must be aligned to multiples of 256.
        public let fontUnicodeRange: String
        /// The map resource associated with the glyph ﬁle.
        public let mapName: String

        public init(fontStack: String, fontUnicodeRange: String, mapName: String) {
            self.fontStack = fontStack
            self.fontUnicodeRange = fontUnicodeRange
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.fontUnicodeRange, name: "fontUnicodeRange", parent: name, pattern: "^[0-9]+-[0-9]+\\.pbf$")
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapGlyphsResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "blob"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw]
        public static var _encoding = [
            AWSMemberEncoding(label: "blob", location: .body(locationName: "Blob")),
            AWSMemberEncoding(label: "contentType", location: .header(locationName: "Content-Type"))
        ]

        /// The blob's content type.
        public let blob: AWSPayload?
        /// The map glyph content type. For example, application/octet-stream.
        public let contentType: String?

        public init(blob: AWSPayload? = nil, contentType: String? = nil) {
            self.blob = blob
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "Blob"
            case contentType = "Content-Type"
        }
    }

    public struct GetMapSpritesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "fileName", location: .uri(locationName: "FileName")),
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName"))
        ]

        /// The name of the sprite ﬁle. Use the following ﬁle names for the sprite sheet:    sprites.png     sprites@2x.png for high pixel density displays   For the JSON document contain image offsets. Use the following ﬁle names:    sprites.json     sprites@2x.json for high pixel density displays
        public let fileName: String
        /// The map resource associated with the sprite ﬁle.
        public let mapName: String

        public init(fileName: String, mapName: String) {
            self.fileName = fileName
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.fileName, name: "fileName", parent: name, pattern: "^sprites(@2x)?\\.(png|json)$")
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapSpritesResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "blob"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw]
        public static var _encoding = [
            AWSMemberEncoding(label: "blob", location: .body(locationName: "Blob")),
            AWSMemberEncoding(label: "contentType", location: .header(locationName: "Content-Type"))
        ]

        /// Contains the body of the sprite sheet or JSON offset ﬁle.
        public let blob: AWSPayload?
        /// The content type of the sprite sheet and offsets. For example, the sprite sheet content type is image/png, and the sprite offset JSON document is application/json.
        public let contentType: String?

        public init(blob: AWSPayload? = nil, contentType: String? = nil) {
            self.blob = blob
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "Blob"
            case contentType = "Content-Type"
        }
    }

    public struct GetMapStyleDescriptorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName"))
        ]

        /// The map resource to retrieve the style descriptor from.
        public let mapName: String

        public init(mapName: String) {
            self.mapName = mapName
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapStyleDescriptorResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "blob"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw]
        public static var _encoding = [
            AWSMemberEncoding(label: "blob", location: .body(locationName: "Blob")),
            AWSMemberEncoding(label: "contentType", location: .header(locationName: "Content-Type"))
        ]

        /// Contains the body of the style descriptor.
        public let blob: AWSPayload?
        /// The style descriptor's content type. For example, application/json.
        public let contentType: String?

        public init(blob: AWSPayload? = nil, contentType: String? = nil) {
            self.blob = blob
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "Blob"
            case contentType = "Content-Type"
        }
    }

    public struct GetMapTileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mapName", location: .uri(locationName: "MapName")),
            AWSMemberEncoding(label: "x", location: .uri(locationName: "X")),
            AWSMemberEncoding(label: "y", location: .uri(locationName: "Y")),
            AWSMemberEncoding(label: "z", location: .uri(locationName: "Z"))
        ]

        /// The map resource to retrieve the map tiles from.
        public let mapName: String
        /// The X axis value for the map tile.
        public let x: String
        /// The Y axis value for the map tile.
        public let y: String
        /// The zoom value for the map tile.
        public let z: String

        public init(mapName: String, x: String, y: String, z: String) {
            self.mapName = mapName
            self.x = x
            self.y = y
            self.z = z
        }

        public func validate(name: String) throws {
            try self.validate(self.mapName, name: "mapName", parent: name, max: 100)
            try self.validate(self.mapName, name: "mapName", parent: name, min: 1)
            try self.validate(self.mapName, name: "mapName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.x, name: "x", parent: name, pattern: "\\d+")
            try self.validate(self.y, name: "y", parent: name, pattern: "\\d+")
            try self.validate(self.z, name: "z", parent: name, pattern: "\\d+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMapTileResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "blob"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw]
        public static var _encoding = [
            AWSMemberEncoding(label: "blob", location: .body(locationName: "Blob")),
            AWSMemberEncoding(label: "contentType", location: .header(locationName: "Content-Type"))
        ]

        /// Contains Mapbox Vector Tile (MVT) data.
        public let blob: AWSPayload?
        /// The map tile's content type. For example, application/vnd.mapbox-vector-tile.
        public let contentType: String?

        public init(blob: AWSPayload? = nil, contentType: String? = nil) {
            self.blob = blob
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "Blob"
            case contentType = "Content-Type"
        }
    }

    public struct ListGeofenceCollectionsRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListGeofenceCollectionsResponse: AWSDecodableShape {
        /// Lists the geofence collections that exist in your AWS account.
        public let entries: [ListGeofenceCollectionsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListGeofenceCollectionsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListGeofenceCollectionsResponseEntry: AWSDecodableShape {
        /// The name of the geofence collection.
        public let collectionName: String
        /// The timestamp for when the geofence collection was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The description for the geofence collection
        public let description: String
        /// Specifies a timestamp for when the resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(collectionName: String, createTime: Date, description: String, updateTime: Date) {
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collectionName = "CollectionName"
            case createTime = "CreateTime"
            case description = "Description"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListGeofenceResponseEntry: AWSDecodableShape {
        /// The timestamp for when the geofence was stored in a geofence collection in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence identifier.
        public let geofenceId: String
        /// Contains the geofence geometry details describing a polygon.
        public let geometry: GeofenceGeometry
        /// Identifies the state of the geofence. A geofence will hold one of the following states:    ACTIVE — The geofence has been indexed by the system.     PENDING — The geofence is being processed by the system.    FAILED — The geofence failed to be indexed by the system.    DELETED — The geofence has been deleted from the system index.    DELETING — The geofence is being deleted from the system index.
        public let status: String
        /// The timestamp for when the geofence was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, geofenceId: String, geometry: GeofenceGeometry, status: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.geometry = geometry
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case geometry = "Geometry"
            case status = "Status"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListGeofencesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName"))
        ]

        /// The name of the geofence collection storing the list of geofences.
        public let collectionName: String
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        public init(collectionName: String, nextToken: String? = nil) {
            self.collectionName = collectionName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct ListGeofencesResponse: AWSDecodableShape {
        /// Contains a list of geofences stored in the geofence collection.
        public let entries: [ListGeofenceResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListGeofenceResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListMapsRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListMapsResponse: AWSDecodableShape {
        /// Contains a list of maps in your AWS account
        public let entries: [ListMapsResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListMapsResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListMapsResponseEntry: AWSDecodableShape {
        /// The timestamp for when the map resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// Specifies the data provider for the associated map tiles.
        public let dataSource: String
        /// The description for the map resource.
        public let description: String
        /// The name of the associated map resource.
        public let mapName: String
        /// The timestamp for when the map resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, dataSource: String, description: String, mapName: String, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapName = mapName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case mapName = "MapName"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListPlaceIndexesRequest: AWSEncodableShape {
        /// An optional limit for the maximum number of results returned in a single call. Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. Default value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPlaceIndexesResponse: AWSDecodableShape {
        /// Lists the Place index resources that exist in your AWS account
        public let entries: [ListPlaceIndexesResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListPlaceIndexesResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListPlaceIndexesResponseEntry: AWSDecodableShape {
        /// The timestamp for when the Place index resource was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The data provider of geospatial data.
        public let dataSource: String
        /// The optional description for the Place index resource.
        public let description: String
        /// The name of the Place index resource.
        public let indexName: String
        /// The timestamp for when the Place index resource was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, dataSource: String, description: String, indexName: String, updateTime: Date) {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.indexName = indexName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case dataSource = "DataSource"
            case description = "Description"
            case indexName = "IndexName"
            case updateTime = "UpdateTime"
        }
    }

    public struct ListTrackerConsumersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trackerName", location: .uri(locationName: "TrackerName"))
        ]

        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?
        /// The tracker resource whose associated geofence collections you want to list.
        public let trackerName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, trackerName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.trackerName = trackerName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, max: 100)
            try self.validate(self.trackerName, name: "trackerName", parent: name, min: 1)
            try self.validate(self.trackerName, name: "trackerName", parent: name, pattern: "^[-._\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackerConsumersResponse: AWSDecodableShape {
        /// Contains the list of geofence collection ARNs associated to the tracker resource.
        public let consumerArns: [String]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(consumerArns: [String], nextToken: String? = nil) {
            self.consumerArns = consumerArns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case consumerArns = "ConsumerArns"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackersRequest: AWSEncodableShape {
        /// An optional limit for the number of resources returned in a single call.  Default value: 100
        public let maxResults: Int?
        /// The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.  Default value: null
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackersResponse: AWSDecodableShape {
        /// Contains tracker resources in your AWS account. Details include tracker name, description and timestamps for when the tracker was created and last updated.
        public let entries: [ListTrackersResponseEntry]
        /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
        public let nextToken: String?

        public init(entries: [ListTrackersResponseEntry], nextToken: String? = nil) {
            self.entries = entries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
            case nextToken = "NextToken"
        }
    }

    public struct ListTrackersResponseEntry: AWSDecodableShape {
        /// The timestamp for when the tracker resource was created in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The description for the tracker resource.
        public let description: String
        /// The name of the tracker resource.
        public let trackerName: String
        /// The timestamp for when the position was detected and sampled in  ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ.
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, description: String, trackerName: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.trackerName = trackerName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case description = "Description"
            case trackerName = "TrackerName"
            case updateTime = "UpdateTime"
        }
    }

    public struct MapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the map style selected from an available data provider. Valid styles: VectorEsriStreets, VectorEsriTopographic, VectorEsriNavigation, VectorEsriDarkGrayCanvas, VectorEsriLightGrayCanvas, VectorHereBerlin.  When using HERE as your data provider, and selecting the Style VectorHereBerlin, you may not use HERE Maps for Asset Management. See the AWS Service Terms for Amazon Location Service.
        public let style: String

        public init(style: String) {
            self.style = style
        }

        public func validate(name: String) throws {
            try self.validate(self.style, name: "style", parent: name, max: 100)
            try self.validate(self.style, name: "style", parent: name, min: 1)
            try self.validate(self.style, name: "style", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case style = "Style"
        }
    }

    public struct Place: AWSDecodableShape {
        /// The numerical portion of an address, such as a building number.
        public let addressNumber: String?
        /// A country/region specified using ISO 3166 3-digit country/region code. For example, CAN.
        public let country: String?
        public let geometry: PlaceGeometry
        /// The full name and address of the point of interest such as a city, region, or country. For example, 123 Any Street, Any Town, USA.
        public let label: String?
        /// A name for a local area, such as a city or town name. For example, Toronto.
        public let municipality: String?
        /// The name of a community district. For example, Downtown.
        public let neighborhood: String?
        /// A group of numbers and letters in a country-specific format, which accompanies the address for the purpose of identifying a location.
        public let postalCode: String?
        /// A name for an area or geographical division, such as a province or state name. For example, British Columbia.
        public let region: String?
        /// The name for a street or a road to identify a location. For example, Main Street.
        public let street: String?
        /// A country, or an area that's part of a larger region . For example, Metro Vancouver.
        public let subRegion: String?

        public init(addressNumber: String? = nil, country: String? = nil, geometry: PlaceGeometry, label: String? = nil, municipality: String? = nil, neighborhood: String? = nil, postalCode: String? = nil, region: String? = nil, street: String? = nil, subRegion: String? = nil) {
            self.addressNumber = addressNumber
            self.country = country
            self.geometry = geometry
            self.label = label
            self.municipality = municipality
            self.neighborhood = neighborhood
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subRegion = subRegion
        }

        private enum CodingKeys: String, CodingKey {
            case addressNumber = "AddressNumber"
            case country = "Country"
            case geometry = "Geometry"
            case label = "Label"
            case municipality = "Municipality"
            case neighborhood = "Neighborhood"
            case postalCode = "PostalCode"
            case region = "Region"
            case street = "Street"
            case subRegion = "SubRegion"
        }
    }

    public struct PlaceGeometry: AWSDecodableShape {
        /// A single point geometry specifies a location for a Place using WGS 84 coordinates:    x — Specifies the x coordinate or longitude.     y — Specifies the y coordinate or latitude.
        public let point: [Double]?

        public init(point: [Double]? = nil) {
            self.point = point
        }

        private enum CodingKeys: String, CodingKey {
            case point = "Point"
        }
    }

    public struct PutGeofenceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "collectionName", location: .uri(locationName: "CollectionName")),
            AWSMemberEncoding(label: "geofenceId", location: .uri(locationName: "GeofenceId"))
        ]

        /// The geofence collection to store the geofence in.
        public let collectionName: String
        /// An identifier for the geofence. For example, ExampleGeofence-1.
        public let geofenceId: String
        /// Contains the polygon details to specify the position of the geofence.
        public let geometry: GeofenceGeometry

        public init(collectionName: String, geofenceId: String, geometry: GeofenceGeometry) {
            self.collectionName = collectionName
            self.geofenceId = geofenceId
            self.geometry = geometry
        }

        public func validate(name: String) throws {
            try self.validate(self.collectionName, name: "collectionName", parent: name, max: 100)
            try self.validate(self.collectionName, name: "collectionName", parent: name, min: 1)
            try self.validate(self.collectionName, name: "collectionName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, max: 100)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, min: 1)
            try self.validate(self.geofenceId, name: "geofenceId", parent: name, pattern: "^[-._\\p{L}\\p{N}]+$")
            try self.geometry.validate(name: "\(name).geometry")
        }

        private enum CodingKeys: String, CodingKey {
            case geometry = "Geometry"
        }
    }

    public struct PutGeofenceResponse: AWSDecodableShape {
        /// The timestamp for when the geofence was created in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var createTime: Date
        /// The geofence identifier entered in the request.
        public let geofenceId: String
        /// The timestamp for when the geofence was last updated in ISO 8601 format: YYYY-MM-DDThh:mm:ss.sssZ
        @CustomCoding<ISO8601DateCoder>
        public var updateTime: Date

        public init(createTime: Date, geofenceId: String, updateTime: Date) {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case geofenceId = "GeofenceId"
            case updateTime = "UpdateTime"
        }
    }

    public struct SearchForPositionResult: AWSDecodableShape {
        /// Contains details about the relevant point of interest.
        public let place: Place

        public init(place: Place) {
            self.place = place
        }

        private enum CodingKeys: String, CodingKey {
            case place = "Place"
        }
    }

    public struct SearchForTextResult: AWSDecodableShape {
        /// Contains details about the relevant point of interest.
        public let place: Place

        public init(place: Place) {
            self.place = place
        }

        private enum CodingKeys: String, CodingKey {
            case place = "Place"
        }
    }

    public struct SearchPlaceIndexForPositionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri(locationName: "IndexName"))
        ]

        /// The name of the Place index resource you want to use for the search.
        public let indexName: String
        /// An optional paramer. The maximum number of results returned per request.  Default value: 50
        public let maxResults: Int?
        /// Specifies a coordinate for the query defined by a longitude, and latitude.   The first position is the X coordinate, or longitude.   The second position is the Y coordinate, or latitude.    For example, position=xLongitude&amp;position=yLatitude .
        public let position: [Double]

        public init(indexName: String, maxResults: Int? = nil, position: [Double]) {
            self.indexName = indexName
            self.maxResults = maxResults
            self.position = position
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.position, name: "position", parent: name, max: 2)
            try self.validate(self.position, name: "position", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case position = "Position"
        }
    }

    public struct SearchPlaceIndexForPositionResponse: AWSDecodableShape {
        /// Returns a list of Places closest to the specified position. Each result contains additional information about the Places returned.
        public let results: [SearchForPositionResult]
        /// Contains a summary of the request.
        public let summary: SearchPlaceIndexForPositionSummary

        public init(results: [SearchForPositionResult], summary: SearchPlaceIndexForPositionSummary) {
            self.results = results
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
            case summary = "Summary"
        }
    }

    public struct SearchPlaceIndexForPositionSummary: AWSDecodableShape {
        /// The data provider of geospatial data for the Place index resource.
        public let dataSource: String
        /// An optional parameter. The maximum number of results returned per request.  Default value: 50
        public let maxResults: Int?
        /// The position given in the reverse geocoding request.
        public let position: [Double]

        public init(dataSource: String, maxResults: Int? = nil, position: [Double]) {
            self.dataSource = dataSource
            self.maxResults = maxResults
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case maxResults = "MaxResults"
            case position = "Position"
        }
    }

    public struct SearchPlaceIndexForTextRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "indexName", location: .uri(locationName: "IndexName"))
        ]

        /// Searches for results closest to the given position. An optional parameter defined by longitude, and latitude.   The first bias position is the X coordinate, or longitude.   The second bias position is the Y coordinate, or latitude.    For example, bias=xLongitude&amp;bias=yLatitude.
        public let biasPosition: [Double]?
        /// Filters the results by returning only Places within the provided bounding box. An optional parameter. The first 2 bbox parameters describe the lower southwest corner:   The first bbox position is the X coordinate or longitude of the lower southwest corner.   The second bbox position is the Y coordinate or latitude of the lower southwest corner.   For example, bbox=xLongitudeSW&amp;bbox=yLatitudeSW. The next bbox parameters describe the upper northeast corner:   The third bbox position is the X coordinate, or longitude of the upper northeast corner.   The fourth bbox position is the Y coordinate, or longitude of the upper northeast corner.   For example, bbox=xLongitudeNE&amp;bbox=yLatitudeNE
        public let filterBBox: [Double]?
        /// Limits the search to the given a list of countries/regions. An optional parameter.   Use the ISO 3166 3-digit country code. For example, Australia uses three upper-case characters: AUS.
        public let filterCountries: [String]?
        /// The name of the Place index resource you want to use for the search.
        public let indexName: String
        /// An optional parameter. The maximum number of results returned per request.  The default: 50
        public let maxResults: Int?
        /// The address, name, city, or region to be used in the search. In free-form text format. For example, 123 Any Street.
        public let text: String

        public init(biasPosition: [Double]? = nil, filterBBox: [Double]? = nil, filterCountries: [String]? = nil, indexName: String, maxResults: Int? = nil, text: String) {
            self.biasPosition = biasPosition
            self.filterBBox = filterBBox
            self.filterCountries = filterCountries
            self.indexName = indexName
            self.maxResults = maxResults
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, max: 2)
            try self.validate(self.biasPosition, name: "biasPosition", parent: name, min: 2)
            try self.validate(self.filterBBox, name: "filterBBox", parent: name, max: 6)
            try self.validate(self.filterBBox, name: "filterBBox", parent: name, min: 4)
            try self.filterCountries?.forEach {
                try validate($0, name: "filterCountries[]", parent: name, pattern: "^[A-Z]{3}$")
            }
            try self.validate(self.filterCountries, name: "filterCountries", parent: name, max: 100)
            try self.validate(self.filterCountries, name: "filterCountries", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 100)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[-._\\w]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.text, name: "text", parent: name, max: 200)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case biasPosition = "BiasPosition"
            case filterBBox = "FilterBBox"
            case filterCountries = "FilterCountries"
            case maxResults = "MaxResults"
            case text = "Text"
        }
    }

    public struct SearchPlaceIndexForTextResponse: AWSDecodableShape {
        /// A list of Places closest to the specified position. Each result contains additional information about the specific point of interest.
        public let results: [SearchForTextResult]
        /// Contains a summary of the request. Contains the BiasPosition, DataSource, FilterBBox, FilterCountries, MaxResults, ResultBBox, and Text.
        public let summary: SearchPlaceIndexForTextSummary

        public init(results: [SearchForTextResult], summary: SearchPlaceIndexForTextSummary) {
            self.results = results
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
            case summary = "Summary"
        }
    }

    public struct SearchPlaceIndexForTextSummary: AWSDecodableShape {
        /// Contains the coordinates for the bias position entered in the geocoding request.
        public let biasPosition: [Double]?
        /// The data provider of geospatial data for the Place index resource.
        public let dataSource: String
        /// Contains the coordinates for the optional bounding box coordinated entered in the geocoding request.
        public let filterBBox: [Double]?
        /// Contains the country filter entered in the geocoding request.
        public let filterCountries: [String]?
        /// Contains the maximum number of results indicated for the request.
        public let maxResults: Int?
        /// A bounding box that contains the search results within the specified area indicated by FilterBBox. A subset of bounding box specified using FilterBBox.
        public let resultBBox: [Double]?
        /// The address, name, city or region to be used in the geocoding request. In free-form text format. For example, Vancouver.
        public let text: String

        public init(biasPosition: [Double]? = nil, dataSource: String, filterBBox: [Double]? = nil, filterCountries: [String]? = nil, maxResults: Int? = nil, resultBBox: [Double]? = nil, text: String) {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCountries = filterCountries
            self.maxResults = maxResults
            self.resultBBox = resultBBox
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case biasPosition = "BiasPosition"
            case dataSource = "DataSource"
            case filterBBox = "FilterBBox"
            case filterCountries = "FilterCountries"
            case maxResults = "MaxResults"
            case resultBBox = "ResultBBox"
            case text = "Text"
        }
    }
}
